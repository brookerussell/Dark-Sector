//
// File generated by rootcint at Thu Sep 24 08:17:39 2015

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME DarkSector_SignalMCCint
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "DarkSector_SignalMCCint.h"

#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOTShadow {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Decay Decay;
      #else
      class Decay  {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::LeptophobicMC LeptophobicMC;
      #else
      class LeptophobicMC  {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Meson Meson;
      #else
      class Meson  {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ProductionCheck ProductionCheck;
      #else
      class ProductionCheck  {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::VB VB;
      #else
      class VB  {
         public:
         //friend XX;
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOTShadow
// END OF SHADOWS

namespace ROOTDict {
   void Decay_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Decay_Dictionary();
   static void *new_Decay(void *p = 0);
   static void *newArray_Decay(Long_t size, void *p);
   static void delete_Decay(void *p);
   static void deleteArray_Decay(void *p);
   static void destruct_Decay(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Decay*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Decay) == sizeof( ::ROOTShadow::Shadow::Decay));
      ::Decay *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Decay),0);
      static ::ROOT::TGenericClassInfo 
         instance("Decay", "./Decay.h", 32,
                  typeid(::Decay), ::ROOT::DefineBehavior(ptr, ptr),
                  &Decay_ShowMembers, &Decay_Dictionary, isa_proxy, 4,
                  sizeof(::Decay) );
      instance.SetNew(&new_Decay);
      instance.SetNewArray(&newArray_Decay);
      instance.SetDelete(&delete_Decay);
      instance.SetDeleteArray(&deleteArray_Decay);
      instance.SetDestructor(&destruct_Decay);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Decay*)
   {
      return GenerateInitInstanceLocal((::Decay*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Decay*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Decay_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Decay*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void LeptophobicMC_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LeptophobicMC_Dictionary();
   static void *new_LeptophobicMC(void *p = 0);
   static void *newArray_LeptophobicMC(Long_t size, void *p);
   static void delete_LeptophobicMC(void *p);
   static void deleteArray_LeptophobicMC(void *p);
   static void destruct_LeptophobicMC(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::LeptophobicMC*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::LeptophobicMC) == sizeof( ::ROOTShadow::Shadow::LeptophobicMC));
      ::LeptophobicMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LeptophobicMC),0);
      static ::ROOT::TGenericClassInfo 
         instance("LeptophobicMC", "./LeptophobicMC.h", 29,
                  typeid(::LeptophobicMC), ::ROOT::DefineBehavior(ptr, ptr),
                  &LeptophobicMC_ShowMembers, &LeptophobicMC_Dictionary, isa_proxy, 4,
                  sizeof(::LeptophobicMC) );
      instance.SetNew(&new_LeptophobicMC);
      instance.SetNewArray(&newArray_LeptophobicMC);
      instance.SetDelete(&delete_LeptophobicMC);
      instance.SetDeleteArray(&deleteArray_LeptophobicMC);
      instance.SetDestructor(&destruct_LeptophobicMC);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::LeptophobicMC*)
   {
      return GenerateInitInstanceLocal((::LeptophobicMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LeptophobicMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LeptophobicMC_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::LeptophobicMC*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void Meson_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Meson_Dictionary();
   static void *new_Meson(void *p = 0);
   static void *newArray_Meson(Long_t size, void *p);
   static void delete_Meson(void *p);
   static void deleteArray_Meson(void *p);
   static void destruct_Meson(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Meson*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Meson) == sizeof( ::ROOTShadow::Shadow::Meson));
      ::Meson *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Meson),0);
      static ::ROOT::TGenericClassInfo 
         instance("Meson", "./Meson.h", 30,
                  typeid(::Meson), ::ROOT::DefineBehavior(ptr, ptr),
                  &Meson_ShowMembers, &Meson_Dictionary, isa_proxy, 4,
                  sizeof(::Meson) );
      instance.SetNew(&new_Meson);
      instance.SetNewArray(&newArray_Meson);
      instance.SetDelete(&delete_Meson);
      instance.SetDeleteArray(&deleteArray_Meson);
      instance.SetDestructor(&destruct_Meson);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Meson*)
   {
      return GenerateInitInstanceLocal((::Meson*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Meson*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Meson_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Meson*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ProductionCheck_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ProductionCheck_Dictionary();
   static void *new_ProductionCheck(void *p = 0);
   static void *newArray_ProductionCheck(Long_t size, void *p);
   static void delete_ProductionCheck(void *p);
   static void deleteArray_ProductionCheck(void *p);
   static void destruct_ProductionCheck(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ProductionCheck*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ProductionCheck) == sizeof( ::ROOTShadow::Shadow::ProductionCheck));
      ::ProductionCheck *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ProductionCheck),0);
      static ::ROOT::TGenericClassInfo 
         instance("ProductionCheck", "./ProductionCheck.h", 30,
                  typeid(::ProductionCheck), ::ROOT::DefineBehavior(ptr, ptr),
                  &ProductionCheck_ShowMembers, &ProductionCheck_Dictionary, isa_proxy, 4,
                  sizeof(::ProductionCheck) );
      instance.SetNew(&new_ProductionCheck);
      instance.SetNewArray(&newArray_ProductionCheck);
      instance.SetDelete(&delete_ProductionCheck);
      instance.SetDeleteArray(&deleteArray_ProductionCheck);
      instance.SetDestructor(&destruct_ProductionCheck);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ProductionCheck*)
   {
      return GenerateInitInstanceLocal((::ProductionCheck*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ProductionCheck*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ProductionCheck_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ProductionCheck*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void VB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void VB_Dictionary();
   static void *new_VB(void *p = 0);
   static void *newArray_VB(Long_t size, void *p);
   static void delete_VB(void *p);
   static void deleteArray_VB(void *p);
   static void destruct_VB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::VB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::VB) == sizeof( ::ROOTShadow::Shadow::VB));
      ::VB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::VB),0);
      static ::ROOT::TGenericClassInfo 
         instance("VB", "./VB.h", 32,
                  typeid(::VB), ::ROOT::DefineBehavior(ptr, ptr),
                  &VB_ShowMembers, &VB_Dictionary, isa_proxy, 4,
                  sizeof(::VB) );
      instance.SetNew(&new_VB);
      instance.SetNewArray(&newArray_VB);
      instance.SetDelete(&delete_VB);
      instance.SetDeleteArray(&deleteArray_VB);
      instance.SetDestructor(&destruct_VB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::VB*)
   {
      return GenerateInitInstanceLocal((::VB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::VB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void VB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::VB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

//______________________________________________________________________________
namespace ROOTDict {
   void LeptophobicMC_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class LeptophobicMC.
      typedef ::ROOTShadow::Shadow::LeptophobicMC ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::LeptophobicMC*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_LeptophobicMC(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LeptophobicMC : new ::LeptophobicMC;
   }
   static void *newArray_LeptophobicMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LeptophobicMC[nElements] : new ::LeptophobicMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_LeptophobicMC(void *p) {
      delete ((::LeptophobicMC*)p);
   }
   static void deleteArray_LeptophobicMC(void *p) {
      delete [] ((::LeptophobicMC*)p);
   }
   static void destruct_LeptophobicMC(void *p) {
      typedef ::LeptophobicMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::LeptophobicMC

//______________________________________________________________________________
namespace ROOTDict {
   void Meson_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Meson.
      typedef ::ROOTShadow::Shadow::Meson ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::Meson*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_Meson(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Meson : new ::Meson;
   }
   static void *newArray_Meson(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Meson[nElements] : new ::Meson[nElements];
   }
   // Wrapper around operator delete
   static void delete_Meson(void *p) {
      delete ((::Meson*)p);
   }
   static void deleteArray_Meson(void *p) {
      delete [] ((::Meson*)p);
   }
   static void destruct_Meson(void *p) {
      typedef ::Meson current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Meson

//______________________________________________________________________________
namespace ROOTDict {
   void VB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class VB.
      typedef ::ROOTShadow::Shadow::VB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::VB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_VB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VB : new ::VB;
   }
   static void *newArray_VB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VB[nElements] : new ::VB[nElements];
   }
   // Wrapper around operator delete
   static void delete_VB(void *p) {
      delete ((::VB*)p);
   }
   static void deleteArray_VB(void *p) {
      delete [] ((::VB*)p);
   }
   static void destruct_VB(void *p) {
      typedef ::VB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::VB

//______________________________________________________________________________
namespace ROOTDict {
   void Decay_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Decay.
      typedef ::ROOTShadow::Shadow::Decay ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::Decay*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_Decay(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Decay : new ::Decay;
   }
   static void *newArray_Decay(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Decay[nElements] : new ::Decay[nElements];
   }
   // Wrapper around operator delete
   static void delete_Decay(void *p) {
      delete ((::Decay*)p);
   }
   static void deleteArray_Decay(void *p) {
      delete [] ((::Decay*)p);
   }
   static void destruct_Decay(void *p) {
      typedef ::Decay current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Decay

//______________________________________________________________________________
namespace ROOTDict {
   void ProductionCheck_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ProductionCheck.
      typedef ::ROOTShadow::Shadow::ProductionCheck ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::ProductionCheck*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ProductionCheck(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ProductionCheck : new ::ProductionCheck;
   }
   static void *newArray_ProductionCheck(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ProductionCheck[nElements] : new ::ProductionCheck[nElements];
   }
   // Wrapper around operator delete
   static void delete_ProductionCheck(void *p) {
      delete ((::ProductionCheck*)p);
   }
   static void deleteArray_ProductionCheck(void *p) {
      delete [] ((::ProductionCheck*)p);
   }
   static void destruct_ProductionCheck(void *p) {
      typedef ::ProductionCheck current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ProductionCheck

/********************************************************
* DarkSector_SignalMCCint.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableDarkSector_SignalMCCint();

extern "C" void G__set_cpp_environmentDarkSector_SignalMCCint() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("Decay.h");
  G__add_compiledheader("LeptophobicMC.h");
  G__add_compiledheader("Meson.h");
  G__add_compiledheader("ProductionCheck.h");
  G__add_compiledheader("VB.h");
  G__cpp_reset_tagtableDarkSector_SignalMCCint();
}
#include <new>
extern "C" int G__cpp_dllrevDarkSector_SignalMCCint() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* Decay */
static int G__DarkSector_SignalMCCint_602_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Decay* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Decay[n];
     } else {
       p = new((void*) gvp) Decay[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Decay;
     } else {
       p = new((void*) gvp) Decay;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_602_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Decay*) G__getstructoffset())->Detector();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DarkSector_SignalMCCint_602_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Decay* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Decay(*(Decay*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Decay G__TDecay;
static int G__DarkSector_SignalMCCint_602_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Decay*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Decay*) (soff+(sizeof(Decay)*i)))->~G__TDecay();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Decay*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Decay*) (soff))->~G__TDecay();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DarkSector_SignalMCCint_602_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Decay* dest = (Decay*) G__getstructoffset();
   const Decay& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LeptophobicMC */
static int G__DarkSector_SignalMCCint_603_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LeptophobicMC* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LeptophobicMC[n];
     } else {
       p = new((void*) gvp) LeptophobicMC[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LeptophobicMC;
     } else {
       p = new((void*) gvp) LeptophobicMC;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_603_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((LeptophobicMC*) G__getstructoffset())->Run();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DarkSector_SignalMCCint_603_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LeptophobicMC* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LeptophobicMC(*(LeptophobicMC*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LeptophobicMC G__TLeptophobicMC;
static int G__DarkSector_SignalMCCint_603_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LeptophobicMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LeptophobicMC*) (soff+(sizeof(LeptophobicMC)*i)))->~G__TLeptophobicMC();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LeptophobicMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LeptophobicMC*) (soff))->~G__TLeptophobicMC();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DarkSector_SignalMCCint_603_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LeptophobicMC* dest = (LeptophobicMC*) G__getstructoffset();
   const LeptophobicMC& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Meson */
static int G__DarkSector_SignalMCCint_604_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Meson* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Meson[n];
     } else {
       p = new((void*) gvp) Meson[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Meson;
     } else {
       p = new((void*) gvp) Meson;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_604_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Meson*) G__getstructoffset())->SetParams();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DarkSector_SignalMCCint_604_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Meson* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Meson(*(Meson*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Meson G__TMeson;
static int G__DarkSector_SignalMCCint_604_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Meson*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Meson*) (soff+(sizeof(Meson)*i)))->~G__TMeson();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Meson*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Meson*) (soff))->~G__TMeson();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DarkSector_SignalMCCint_604_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Meson* dest = (Meson*) G__getstructoffset();
   *dest = *(Meson*) libp->para[0].ref;
   const Meson& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ProductionCheck */
static int G__DarkSector_SignalMCCint_605_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ProductionCheck* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ProductionCheck[n];
     } else {
       p = new((void*) gvp) ProductionCheck[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ProductionCheck;
     } else {
       p = new((void*) gvp) ProductionCheck;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_605_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ProductionCheck*) G__getstructoffset())->CheckAll();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DarkSector_SignalMCCint_605_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ProductionCheck* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ProductionCheck(*(ProductionCheck*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ProductionCheck G__TProductionCheck;
static int G__DarkSector_SignalMCCint_605_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ProductionCheck*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ProductionCheck*) (soff+(sizeof(ProductionCheck)*i)))->~G__TProductionCheck();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ProductionCheck*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ProductionCheck*) (soff))->~G__TProductionCheck();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DarkSector_SignalMCCint_605_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ProductionCheck* dest = (ProductionCheck*) G__getstructoffset();
   const ProductionCheck& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* VB */
static int G__DarkSector_SignalMCCint_606_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VB[n];
     } else {
       p = new((void*) gvp) VB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VB;
     } else {
       p = new((void*) gvp) VB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_606_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((VB*) G__getstructoffset())->PseudoscalarMeson();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DarkSector_SignalMCCint_606_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((VB*) G__getstructoffset())->VectorMeson();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DarkSector_SignalMCCint_606_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   VB* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new VB(*(VB*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef VB G__TVB;
static int G__DarkSector_SignalMCCint_606_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (VB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((VB*) (soff+(sizeof(VB)*i)))->~G__TVB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (VB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((VB*) (soff))->~G__TVB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DarkSector_SignalMCCint_606_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VB* dest = (VB*) G__getstructoffset();
   const VB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* Decay */

/* LeptophobicMC */

/* Meson */

/* ProductionCheck */

/* VB */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncDarkSector_SignalMCCint {
 public:
  G__Sizep2memfuncDarkSector_SignalMCCint(): p(&G__Sizep2memfuncDarkSector_SignalMCCint::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncDarkSector_SignalMCCint::*p)();
};

size_t G__get_sizep2memfuncDarkSector_SignalMCCint()
{
  G__Sizep2memfuncDarkSector_SignalMCCint a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceDarkSector_SignalMCCint() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableDarkSector_SignalMCCint() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<std::string,TObjArray*>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*,less<string> >",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTBaselEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Double_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTBaselEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TVectorTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Double_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TVectorTlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixT<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTColumn_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTFlat_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSub_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSparseRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag_const<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSparseDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTColumnlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTFlatlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSublEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSparseRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TMatrixTSparseDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementActionT<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TElementActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementPosActionT<Float_t>",117,G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_TElementPosActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* Decay */
static void G__setup_memvarDecay(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay));
   { Decay *p; p=(Decay*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* LeptophobicMC */
static void G__setup_memvarLeptophobicMC(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC));
   { LeptophobicMC *p; p=(LeptophobicMC*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Meson */
static void G__setup_memvarMeson(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson));
   { Meson *p; p=(Meson*)0x1000; if (p) { }
   G__memvar_setup((void*)0,102,0,0,-1,-1,-2,2,"_mass=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-2,2,"_px=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-2,2,"_py=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-2,2,"_pz=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ProductionCheck */
static void G__setup_memvarProductionCheck(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck));
   { ProductionCheck *p; p=(ProductionCheck*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* VB */
static void G__setup_memvarVB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB));
   { VB *p; p=(VB*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarDarkSector_SignalMCCint() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncDecay(void) {
   /* Decay */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay));
   G__memfunc_setup("Decay",486,G__DarkSector_SignalMCCint_602_0_1, 105, G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Detector",826,G__DarkSector_SignalMCCint_602_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Decay", 486, G__DarkSector_SignalMCCint_602_0_3, (int) ('i'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay), -1, 0, 1, 1, 1, 0, "u 'Decay' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Decay", 612, G__DarkSector_SignalMCCint_602_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DarkSector_SignalMCCint_602_0_5, (int) ('u'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Decay), -1, 1, 1, 1, 1, 0, "u 'Decay' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLeptophobicMC(void) {
   /* LeptophobicMC */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC));
   G__memfunc_setup("LeptophobicMC",1289,G__DarkSector_SignalMCCint_603_0_1, 105, G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Run",309,G__DarkSector_SignalMCCint_603_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LeptophobicMC", 1289, G__DarkSector_SignalMCCint_603_0_3, (int) ('i'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC), -1, 0, 1, 1, 1, 0, "u 'LeptophobicMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LeptophobicMC", 1415, G__DarkSector_SignalMCCint_603_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DarkSector_SignalMCCint_603_0_5, (int) ('u'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_LeptophobicMC), -1, 1, 1, 1, 1, 0, "u 'LeptophobicMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMeson(void) {
   /* Meson */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson));
   G__memfunc_setup("Meson",514,G__DarkSector_SignalMCCint_604_0_1, 105, G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetParams",912,G__DarkSector_SignalMCCint_604_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Meson", 514, G__DarkSector_SignalMCCint_604_0_3, (int) ('i'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson), -1, 0, 1, 1, 1, 0, "u 'Meson' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Meson", 640, G__DarkSector_SignalMCCint_604_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DarkSector_SignalMCCint_604_0_5, (int) ('u'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_Meson), -1, 1, 1, 1, 1, 0, "u 'Meson' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncProductionCheck(void) {
   /* ProductionCheck */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck));
   G__memfunc_setup("ProductionCheck",1541,G__DarkSector_SignalMCCint_605_0_1, 105, G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CheckAll",759,G__DarkSector_SignalMCCint_605_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProductionCheck", 1541, G__DarkSector_SignalMCCint_605_0_3, (int) ('i'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck), -1, 0, 1, 1, 1, 0, "u 'ProductionCheck' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProductionCheck", 1667, G__DarkSector_SignalMCCint_605_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DarkSector_SignalMCCint_605_0_5, (int) ('u'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_ProductionCheck), -1, 1, 1, 1, 1, 0, "u 'ProductionCheck' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncVB(void) {
   /* VB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB));
   G__memfunc_setup("VB",152,G__DarkSector_SignalMCCint_606_0_1, 105, G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PseudoscalarMeson",1768,G__DarkSector_SignalMCCint_606_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VectorMeson",1141,G__DarkSector_SignalMCCint_606_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VB", 152, G__DarkSector_SignalMCCint_606_0_4, (int) ('i'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB), -1, 0, 1, 1, 1, 0, "u 'VB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VB", 278, G__DarkSector_SignalMCCint_606_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DarkSector_SignalMCCint_606_0_6, (int) ('u'), G__get_linked_tagnum(&G__DarkSector_SignalMCCintLN_VB), -1, 1, 1, 1, 1, 0, "u 'VB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncDarkSector_SignalMCCint() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {
}

static void G__cpp_setup_global4() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalDarkSector_SignalMCCint() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
  G__cpp_setup_global4();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcDarkSector_SignalMCCint() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR = { "map<string,TObjArray*,less<string>,allocator<pair<const string,TObjArray*> > >" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTBaselEfloatgR = { "TMatrixTBase<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTBaselEdoublegR = { "TMatrixTBase<double>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TVectorTlEfloatgR = { "TVectorT<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TVectorTlEdoublegR = { "TVectorT<double>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TElementActionTlEfloatgR = { "TElementActionT<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TElementPosActionTlEfloatgR = { "TElementPosActionT<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTlEfloatgR = { "TMatrixT<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTRow_constlEfloatgR = { "TMatrixTRow_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTRowlEfloatgR = { "TMatrixTRow<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTDiag_constlEfloatgR = { "TMatrixTDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTColumn_constlEfloatgR = { "TMatrixTColumn_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTFlat_constlEfloatgR = { "TMatrixTFlat_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSub_constlEfloatgR = { "TMatrixTSub_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSparseRow_constlEfloatgR = { "TMatrixTSparseRow_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSparseDiag_constlEfloatgR = { "TMatrixTSparseDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTColumnlEfloatgR = { "TMatrixTColumn<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTDiaglEfloatgR = { "TMatrixTDiag<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTFlatlEfloatgR = { "TMatrixTFlat<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSublEfloatgR = { "TMatrixTSub<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSparseRowlEfloatgR = { "TMatrixTSparseRow<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_TMatrixTSparseDiaglEfloatgR = { "TMatrixTSparseDiag<float>" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_Decay = { "Decay" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_LeptophobicMC = { "LeptophobicMC" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_Meson = { "Meson" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_ProductionCheck = { "ProductionCheck" , 99 , -1 };
G__linked_taginfo G__DarkSector_SignalMCCintLN_VB = { "VB" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableDarkSector_SignalMCCint() {
  G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTBaselEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTBaselEdoublegR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TVectorTlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TVectorTlEdoublegR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TElementActionTlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TElementPosActionTlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTRow_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTRowlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTDiag_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTColumn_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTFlat_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSub_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSparseRow_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSparseDiag_constlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTColumnlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTDiaglEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTFlatlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSublEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSparseRowlEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_TMatrixTSparseDiaglEfloatgR.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_Decay.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_LeptophobicMC.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_Meson.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_ProductionCheck.tagnum = -1 ;
  G__DarkSector_SignalMCCintLN_VB.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableDarkSector_SignalMCCint() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTBaselEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTBaselEdoublegR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TVectorTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TVectorTlEdoublegR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TElementActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TElementPosActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTColumn_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTFlat_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSub_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSparseRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSparseDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTColumnlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTFlatlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSublEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSparseRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_TMatrixTSparseDiaglEfloatgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_Decay),sizeof(Decay),-1,263424,(char*)NULL,G__setup_memvarDecay,G__setup_memfuncDecay);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_LeptophobicMC),sizeof(LeptophobicMC),-1,263424,(char*)NULL,G__setup_memvarLeptophobicMC,G__setup_memfuncLeptophobicMC);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_Meson),sizeof(Meson),-1,263424,(char*)NULL,G__setup_memvarMeson,G__setup_memfuncMeson);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_ProductionCheck),sizeof(ProductionCheck),-1,263424,(char*)NULL,G__setup_memvarProductionCheck,G__setup_memfuncProductionCheck);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DarkSector_SignalMCCintLN_VB),sizeof(VB),-1,263424,(char*)NULL,G__setup_memvarVB,G__setup_memfuncVB);
}
extern "C" void G__cpp_setupDarkSector_SignalMCCint(void) {
  G__check_setup_version(30051515,"G__cpp_setupDarkSector_SignalMCCint()");
  G__set_cpp_environmentDarkSector_SignalMCCint();
  G__cpp_setup_tagtableDarkSector_SignalMCCint();

  G__cpp_setup_inheritanceDarkSector_SignalMCCint();

  G__cpp_setup_typetableDarkSector_SignalMCCint();

  G__cpp_setup_memvarDarkSector_SignalMCCint();

  G__cpp_setup_memfuncDarkSector_SignalMCCint();
  G__cpp_setup_globalDarkSector_SignalMCCint();
  G__cpp_setup_funcDarkSector_SignalMCCint();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncDarkSector_SignalMCCint();
  return;
}
class G__cpp_setup_initDarkSector_SignalMCCint {
  public:
    G__cpp_setup_initDarkSector_SignalMCCint() { G__add_setup_func("DarkSector_SignalMCCint",(G__incsetup)(&G__cpp_setupDarkSector_SignalMCCint)); G__call_setup_funcs(); }
   ~G__cpp_setup_initDarkSector_SignalMCCint() { G__remove_setup_func("DarkSector_SignalMCCint"); }
};
G__cpp_setup_initDarkSector_SignalMCCint G__cpp_setup_initializerDarkSector_SignalMCCint;

